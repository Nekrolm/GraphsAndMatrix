## Матрица смежности. Пути.

Для прикладных задач важен и полезен анализ путей на графе. 

Начнем с простого вопроса: а сколькими способами можно перейти из одной вершины в другую?
Ясно-понятно, что если между вершинами можно найти контур, ответ -- бесконечно много: сколь угодно долго ходи по контуру, а потом иди в нужную вершину. Поэтому нужно либо рассматривать графы без контуров, либо поставить вопрос по-другому: а сколько всего путей длины `N` между каждой парой вершин?

Пусть на этот вопрос (сколько путей длины ровно `N` между вершинами `x` и `y`?) будет отвечать функция `P(N, x,y)`. При фиксированом `N`, `P(N)` -- матрица размера `|V|x|V|`.

Очевидно: `P(0) = I`. Есть единственный способ остаться в одной и той же вершине, сделав ноль шагов. И ни одного способа перейти из одной вершины в другую.

`P(1)` -- это матрица `A`. Там где есть дуга, там и есть один способ перейти. Где нет -- способа нет.

А `P(2)`? Вспомните отношение, котрое мы строили, анализируя компоненты сильной связности. Тут то же самое, только умножение нормлаьное матричное без битовых операций. Так что `P(2) = P(1) * A`

И в принципе `P(N) = A^N`

А если граф будет взвешеный? Если вес дуги -- вероятность перехода по ней. Какова тогда вероятность перейти из одной вершины в другую за `N` шагов? `A^N`.

А если веса задают длины дуг, какова длина кратчайшего пути из `N` дуг? `A^N`! Стоп, что?! Это же бред!
Да. И нет. Смотря над каким полукольцом матрица!

Итак, полукольцо -- множество `S` с введенными на нем двумя бинарными операциями: сложением `plus` и умножением `times`.

От `plus` требуем:
1. Коммутативность: `plus(a, b) = plus(b, a)`. 
2. Ассоциативность: `plus(a, plus(b,c)) = plus(plus(a, b), c)`
3. Чтоб ноль был: `plus(a, 0) = plus(0, a) = a`
От `times` требуем:
1. Ассоциативность: `times(a, times(b,c)) = times(times(a, b), c)`
2. Чтоб единица была (полуколько с единицей у нас будет!):
    `times(1, a) = times(a, 1) = a`
3. Дистрибутивность относительно `plus`:
    - `times(plus(a, b), c) = plus(times(a, c), times(b, c))`
    - `times(c, plus(a, b)) = plus(times(c, a), times(c, b))`
4. И чтоб ноль как обычно работал:
    `times(a, 0) = times(0, a) = 0`

Когда мы работали со связностью, у нас было двухэлементое полуколько {0, 1} c операциями `plus` = `or`, `times` = `and`. Да еще и не абы какое, а идемпотентное! То есть `plus(a, a) = a` для всех элементов `a`.

От того у нас так лихо `sum(A^i for i in [0,..N])`  в  `(I + A)^N` превратилось. Это для любого идемпотентного полуколечка верно.

Когда мы количество путей считаем, у нас тоже полукольцо, оно же кольцо. Оно же целые числа. А можно сказать, что не целые, а вещественные. Да и отрицательные нам не интересны. Такое полукольцо вероятностным зовется! В вопросе про вероятности как раз оно участвует.

А что в случае кратчайших путей? А тут у нас в качестве `times` -- обычный плюс, а `plus` -- минимум! В качестве `1` -- обычный нуль. А в качестве `0` -- бесконечность положительная. Так-то. Поподставляйте в требования -- все сойдется. И полукольцо такое тропическим зовется. Потому что Бразилию южный тропик пересекает... 

И смысл в этой бессмыслице есть. Вот в случае с вероятностями: вероятность пройти подряд по двум дугам -- произведение вероятностей, написанных на каждой. Длина двух дуг -- сумма длин. И там и там операция `times`. Вероятности пройти по разным путям в одну и ту же вершину мы складываем. А из длин выбираем минимальную. И там и там `plus`. 

Так что длины кратчайших путей из `N` дуг -- `A^N`. В тропическом полукольце. Только с единичной матрицей главное не напутать! `A^0` --- нолики (они же `1` в полукольце) на диагонали, бесконечности (они же `0`) -- в остальном. И там, где дуг в графе нет, в матрице `A` -- бесконечности стоят.

Соответсвенно, длины кратчайших путей, в которых не более `N` дуг:  `sum(A^i for i in [0,..N])`, что в тропическом полукольце (а минимум-то идемпотентен!) есть просто `(I + A)^N`. Если в графе нет контуров отрицательного веса, подставляй вместо `N` количество вершин `|V|` и получай длины всех пар самых кратчайших путей вообще.

Так что ж получается-то! Вот для сложного вопроса про кратчайшие пути такая простая и красивая формула `(I + A)^N`, а для простого про количество путей (сколько путей длины не более `N`?) -- сумму матриц разных степеней считай? Ну нет, так дело не пойдет. Давайте красиво сделаем всегда и везде.

Что такое `P(N-1) * A`? Это мы для каждой вершины `y` перебираем все дуги (`x`, `y`), входящие в нее, и суммируем количества путей до каждого такого `x`. И нам тут как раз идемпотентности не хватает, чтоб лишнего не проссуммировать... Что же делать? Сейчас придумаем.

Давайте-ка сумму степеней матриц за `S(N)` обозначим. 

- `A^(N+1)  = A * A^N` -- верно? 
- `S(N) =  A^N + S(N-1)` -- так?
- `S(N) =  I * A^N + I * S(N-1)` -- ну-ка, ну-ка ... а что если?
- `A^(N+1) =  A * A^N + 0 * S(N-1)`  -- ага! 

Перейдем к матрицам, элементы которых -- матрицы! Такие матрицы еще блочными зовутся.
Получается, у нас тут всего-то двухмерная матрица
```
M = [ 
     [ A, I ]
     [ 0, I ]
    ]
```

к которой слева надо для умножения приписать двухэлементный вектор `(A^N, S(N-1))`

Начинаем с вектора `(A, I)`. Умножаем на `M` сколько нужно раз `N` -- получем `(A^(N+1), S(N))`. Мы восхитительны!

А что произошло на графе при переходе к матрице `M`? Да все просто: каждая вершина `y` раздвоилась на 
`y` и `y'`. В `y'` провели петлю, не влияющую на количество путей ведущих в `y'`. И из `y` провели дугу в `y'`. Позволяющую накапливать новые пути, ведущие в `y'`. И фактически, мы теперь считаем не количество путей из `x` в `y`, а количество путей из `x` в `y'`. 

И такая махинация уже для любого полукольца пройдет. Такие дела.
